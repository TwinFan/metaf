<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="description" content="Metaf library usage example: short weather summary for aerodromes near your location">
	<title>Short weather summary for aerodromes near your location based on METAR/TAF weather data</title>
	<link rel="stylesheet" type="text/css" href="../style.css">
	<link rel="stylesheet" type="text/css" href="weather_widget/weather_widget.css">
	<style type="text/css">
		.weatherdataitem {
			margin: 1em;		
			padding: 1em;
			background-color: #557a95;
			border-color: #ffffff;
			overflow: hidden;
		}

		.weatherstation {
			background-color: #445a69;
			border:none;
		}

		.widget {
			background-color: #445a69;
			float:left;
			margin: 0.5em;	
			padding: 0.5em;
		}

		.weathertext {
			margin: 0.5em;		
		}

		.options {
			list-style-type: none;
			padding: 1em;
			margin: 1em;
			overflow: hidden;
			background-color: #557a95;
		}

		.options_caption {
			background-color: #445a69;
			border:none;
			display:block;
		}

		.option {
			float: left;
		}

		.option a {
			display: block;
			color: #ffffff;
			text-align: center;
			margin:0.75em;
			text-decoration: none;
		}

		.option a:focus {
		    outline: none !important;
		}

		.option:hover:not(.option_on) {
			background-color: #b1a296;
		}

		.option_on {
			background-color: #445a69;
		}

	}
	</style>
	<script>
		//Get time zone offset (in minutes) based on time set on device and reference GMT time (e.g. server's responce) which is assumed to be correct
		//Also assumed that the actual local time is set correctly (though time zone on device may be wrong)
		function getActualTimeOffset(localTimeGMT, referenceTimeGMT) {
			const localTimeWithTzOffset = new Date(
				localTimeGMT.getTime() - localTimeGMT.getTimezoneOffset() * 60000);
			return Math.round((localTimeWithTzOffset - referenceTimeGMT)/60000);
		}

		function distanceKm(lat1, lon1, lat2, lon2) {
			//based on https://www.geodatasource.com/developers/javascript
			//returns value in kilometers
			if ((lat1 == lat2) && (lon1 == lon2)) {
				return 0;
			}
			else {
				var radlat1 = Math.PI * lat1/180;
				var radlat2 = Math.PI * lat2/180;
				var theta = lon1-lon2;
				var radtheta = Math.PI * theta/180;
				var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);
				if (dist > 1) {
					dist = 1;
				}
				const kmPerMile = 1.609344;
				dist = Math.acos(dist);
				dist = dist * 180/Math.PI;
				dist = dist * 60 * 1.1515 * kmPerMile;
				return dist;
			}
		}

		function fetchAndParseXML(url) {
			var actualOffsetFromGMT;
			return fetch(url)
				.catch(err => { 
					console.log("Fetch from AWC failed: ", err, " (URL:", url, ")")
				})
				.then(response => {
					actualOffsetFromGMT = getActualTimeOffset(
						new Date(), 
						new Date(response.headers.get("date")));
					return response;
				})
				.then(response => response.text())
				.then(responseText => [new window.DOMParser().parseFromString(responseText, "text/xml"), actualOffsetFromGMT])
				.catch(err => {
					console.log("XML processing failed: ", err, " (URL:", url, ")")
				})			
		}

		function getStationFromNodeList(nodeList) {
			var station_id, station_name;
			nodeList.forEach(value => {
				const valData = value.innerHTML;
				switch(value.localName) {
					case "station_id": station_id = valData; break;
					case "site": station_name = valData; break;
					default: break;	
				}
			});
			return {id:station_id, name:station_name}
		}

		function getReportFromNodeList(nodeList) {
			var station_id, station_lat, station_lon, station_report;
			nodeList.forEach(value => {
				const valData = value.innerHTML;
				switch(value.localName) {
					case "raw_text": station_report = valData; break;
					case "station_id": station_id = valData; break;
					case "latitude": station_lat = valData; break;
					case "longitude": station_lon = valData; break;
					default: break;				
				}
			});
			return {id:station_id, lat:station_lat, lon:station_lon, report:station_report}
		}

		function nullIfNoValue(data, noValue) {
			if (data == noValue) return(null);
			return(data);
		}

		function adaptCurrentWeather(currentWeather, noValue) {
			//Set values to null if they are not specified
			currentWeather.windDirection = nullIfNoValue(currentWeather.windDirection, noValue);
			currentWeather.windSpeed = nullIfNoValue(currentWeather.windSpeed, noValue);
			currentWeather.gustSpeed = nullIfNoValue(currentWeather.gustSpeed, noValue);
			currentWeather.visibility = nullIfNoValue(currentWeather.visibility, noValue);
			currentWeather.airTemperature = nullIfNoValue(currentWeather.airTemperature, noValue);
			currentWeather.perceivedTemperature = nullIfNoValue(currentWeather.perceivedTemperature, noValue);
			currentWeather.airTemperatureHigh = nullIfNoValue(currentWeather.airTemperatureHigh, noValue);
			currentWeather.airTemperatureLow = nullIfNoValue(currentWeather.airTemperatureLow, noValue);
			currentWeather.relativeHumidity = nullIfNoValue(currentWeather.relativeHumidity, noValue);
			currentWeather.atmosphericPressure = nullIfNoValue(currentWeather.atmosphericPressure, noValue);
			currentWeather.updateYear = nullIfNoValue(currentWeather.updateYear, noValue);
			currentWeather.updateMonth = nullIfNoValue(currentWeather.updateMonth, noValue);
			currentWeather.updateDay = nullIfNoValue(currentWeather.updateDay, noValue);
			currentWeather.updateHour = nullIfNoValue(currentWeather.updateHour, noValue);
			currentWeather.updateMinute = nullIfNoValue(currentWeather.updateMinute, noValue);
			//Convert vector<int> object to js array
			var weatherArray = Array();
			const weatherVector = currentWeather.weather;
			for (var i = 0; i < weatherVector.size(); i++) {
				weatherArray.push(weatherVector.get(i));
			}
			currentWeather.weather = weatherArray;
			return(currentWeather);
		}

		function cloudToText (cloud) {
			switch (cloud) {
				case Module.Cloud.NOT_SPECIFIED.value: 	return "Cloud data not specified";
				case Module.Cloud.CLEAR.value: 			return "Clear";
				case Module.Cloud.MOSTLY_CLEAR.value: 	return "Mostly clear";
				case Module.Cloud.MOSTLY_CLOUDY.value: 	return "Mostly cloudy";
				case Module.Cloud.OVERCAST.value: 		return "Overcast";
				default:								return "Cloud data unknown";
			}
		}

		function weatherPhenomenaToText(phenomena) {
			switch (phenomena) {
				case Module.Weather.NOT_SPECIFIED.value:
				return "Weather data not specified";

				case Module.Weather.PRECIPITATION_IN_VICINITY.value:
				return "Precipitation in vicinity";

				case Module.Weather.THUNDERSTORM_IN_VICINITY.value:
				return "Thunderstorm in vicinity";

				case Module.Weather.FOG_IN_VICINITY.value:
				return "Fog in vicinity";

				case Module.Weather.VOLCANIC_ASH_IN_VICINITY.value:
				return "Volcanic ash in vicinity";

				case Module.Weather.DUST_WHIRLS_IN_VICINITY.value:
				return "Sand or dust whirls in vicinity";

				case Module.Weather.BLOWING_SNOW_IN_VICINITY.value:
				return "Blowing snow in vicinity";

				case Module.Weather.BLOWING_DUST_IN_VICINITY.value:
				return "Blowing dust in vicinity";

				case Module.Weather.BLOWING_SAND_IN_VICINITY.value:
				return "Blowing sand in vicinity";

				case Module.Weather.SANDSTORM_IN_VICINITY.value:
				return "Sand storm in vicinity";

				case Module.Weather.DUSTSTORM_IN_VICINITY.value:
				return "Dust storm in vicinity";

				case Module.Weather.DRIFTING_SAND.value:
				return "Low drifting sand";

				case Module.Weather.DRIFTING_DUST.value:
				return "Low drifting dust";

				case Module.Weather.DRIFTING_SNOW.value:
				return "Low drifting snow";

				case Module.Weather.BLOWING_SAND.value:
				return "Blowing sand";

				case Module.Weather.BLOWING_DUST.value:
				return "Blowing dust";

				case Module.Weather.BLOWING_SNOW.value:
				return "Blowing snow";

				case Module.Weather.BLOWING_SPRAY.value:
				return "Blowing spray";

				case Module.Weather.FOG.value:
				return "Fog";

				case Module.Weather.FOG_SHALLOW.value:
				return "Ground fog";

				case Module.Weather.FOG_PARTIAL.value:
				return "Location partly covered by fog";

				case Module.Weather.FOG_PATCHES.value:
				return "Random patches of fog";

				case Module.Weather.FOG_FREEZING.value:
				return "Freezing fog";

				case Module.Weather.ICE_CRYSTALS.value:
				return "Airborne ice crystals (diamond dust)";

				case Module.Weather.MIST.value:
				return "Mist";

				case Module.Weather.SMOKE.value:
				return "Smoke";

				case Module.Weather.VOLCANIC_ASH.value:
				return "Volcanic ash";

				case Module.Weather.WIDESPREAD_DUST.value:
				return "Widespread dust";

				case Module.Weather.SAND.value:
				return "Airborne sand particles";

				case Module.Weather.HAZE.value:
				return "Haze";

				case Module.Weather.DRIZZLE_LIGHT.value:
				return "Light drizzle";

				case Module.Weather.DRIZZLE_MODERATE.value:
				return "Moderate drizzle";

				case Module.Weather.DRIZZLE_HEAVY.value:
				return "Heavy drizzle";

				case Module.Weather.RAIN_LIGHT.value:
				return "Light rain";

				case Module.Weather.RAIN_MODERATE.value:
				return "Moderate rain";

				case Module.Weather.RAIN_HEAVY.value:
				return "Heavy rain";

				case Module.Weather.SNOW_LIGHT.value:
				return "Light snow";

				case Module.Weather.SNOW_MODERATE.value:
				return "Moderate snow";

				case Module.Weather.SNOW_HEAVY.value:
				return "Heavy snow";

				case Module.Weather.ICE_PELLETS_LIGHT.value:
				return "Ice pellets (light intensity)";

				case Module.Weather.ICE_PELLETS_MODERATE.value:
				return "Ice pellets (moderate intensity)";

				case Module.Weather.ICE_PELLETS_HEAVY.value:
				return "Ice pellets (heavy intensity)";

				case Module.Weather.SNOW_GRAINS_LIGHT.value:
				return "Snow grains (light intensity)";

				case Module.Weather.SNOW_GRAINS_MODERATE.value:
				return "Snow grains (moderate intensity)";

				case Module.Weather.SNOW_GRAINS_HEAVY.value:
				return "Snow grains (heavy intensity)";

				case Module.Weather.GRAUPEL.value:
				return "Graupel";

				case Module.Weather.HAIL.value:
				return "Hail";

				case Module.Weather.UNDETERMINED_LIGHT.value:
				return "Undetermined precipitation (light)";

				case Module.Weather.UNDETERMINED_MODERATE.value:
				return "Undetermined precipitation (moderate)";

				case Module.Weather.UNDETERMINED_HEAVY.value:
				return "Undetermined precipitation (heavy)";

				case Module.Weather.RAIN_SHOWERS_LIGHT.value:
				return "Light showers";

				case Module.Weather.RAIN_SHOWERS_MODERATE.value:
				return "Moderate showers";

				case Module.Weather.RAIN_SHOWERS_HEAVY.value:
				return "Heavy showers";

				case Module.Weather.SNOW_SHOWERS_LIGHT.value:
				return "Light snow showers";

				case Module.Weather.SNOW_SHOWERS_MODERATE.value:
				return "Moderate snow showers";

				case Module.Weather.SNOW_SHOWERS_HEAVY.value:
				return "Heavy snow showers";

				case Module.Weather.ICE_PELLETS_SHOWERS_LIGHT.value:
				return "Light ice pellet showers";

				case Module.Weather.ICE_PELLETS_SHOWERS_MODERATE.value:
				return "Moderate ice pellet showers";

				case Module.Weather.ICE_PELLETS_SHOWERS_HEAVY.value:
				return "Heavy ice pellet showers";

				case Module.Weather.DRIZZLE_FREEZING_LIGHT.value:
				return "Light freezing drizzle";

				case Module.Weather.DRIZZLE_FREEZING_MODERATE.value:
				return "Moderate freezing drizzle";

				case Module.Weather.DRIZZLE_FREEZING_HEAVY.value:
				return "Heavy freezing drizzle";

				case Module.Weather.RAIN_FREEZING_LIGHT.value:
				return "Light freezing rain";

				case Module.Weather.RAIN_FREEZING_MODERATE.value:
				return "Moderate freezing rain";

				case Module.Weather.RAIN_FREEZING_HEAVY.value:
				return "Heavy freezing rain";

				case Module.Weather.THUNDERSTORM.value:
				return "Thunderstorm";

				case Module.Weather.DUST_WHIRLS.value:
				return "Sand or dust whirls";

				case Module.Weather.SQUALLS.value:
				return "Squalls";

				case Module.Weather.FUNNEL_CLOUD.value:
				return "Funnel cloud";

				case Module.Weather.TORNADO.value:
				return "Tornado or waterspout";

				case Module.Weather.SANDSTORM.value:
				return "Sand storm";

				case Module.Weather.SANDSTORM_HEAVY.value:
				return "Heavy sand storm";

				case Module.Weather.DUSTSTORM.value:
				return "Dust storm";

				case Module.Weather.DUSTSTORM_HEAVY.value:
				return "Heavy dust storm";

				default:
				return "Unknown weather phenomena";
			}
		}

		function weatherToText (weather, eol) {
			var result = "";
			weather.forEach(value => {
				result += weatherPhenomenaToText(value);
				result += eol;
			});
			return result;
		}

		function directionToCardinalText (degrees) {
			if (degrees > 360) return(null);
			if (degrees == 360) return("true north");
			if (degrees == 90) return("true east");
			if (degrees == 180) return("true south");
			if (degrees == 270) return("true west");
			if (degrees <= 11) return("north");
			if (degrees <= 33) return("north-northeast");
			if (degrees <= 56) return("northeast");
			if (degrees <= 78) return("east-northeast");
			if (degrees <= 101) return("east");
			if (degrees <= 123) return("east-southeast");
			if (degrees <= 146) return("southeast");
			if (degrees <= 168) return("south-southeast");
			if (degrees <= 191) return("south");
			if (degrees <= 213) return("south-southwest");
			if (degrees <= 236) return("southwest");
			if (degrees <= 258) return("west-southwest");
			if (degrees <= 281) return("west");
			if (degrees <= 303) return("west-northwest");
			if (degrees <= 326) return("northwest");
			if (degrees <= 348) return("north-northwest");
			return("north"); // 349 to 360
		}

		function dateTimeToStr_HH_MM(time) {
			var result = "";
			const decimalRadix = 10;
			if (time.getHours() < 10) result += "0";
			result += time.getHours().toString(decimalRadix);
			result += ":"
			if (time.getMinutes() < 10) result += "0";
			result += time.getMinutes().toString(decimalRadix);
			return result;
 		}

		function dateTimeToStr_DD_MMM_YYYY_HH_MM(time) {
			var result = "";
			const decimalRadix = 10;
			result += time.getDate().toString(decimalRadix);
			result += " ";
			const monthStrs = [
				"JAN", "FEB", "MAR", "APR", "MAY", "JUN", 
				"JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
			result += monthStrs[time.getMonth()];
			result += " ";
			result += time.getFullYear().toString(decimalRadix);
			result += " ";
			result += dateTimeToStr_HH_MM(time);
			return result;
 		}

 		function timeDifferenceMinutesToString(timeDiffMinutes) {
 			if (!timeDiffMinutes) return("just now");
 			const minPerHour = 60;
 			const timeDiffHours = Math.trunc(timeDiffMinutes / minPerHour);
 			const timeDiffMinutesOfHour = timeDiffMinutes - timeDiffHours * minPerHour;
 			var result = "";
 			switch(timeDiffHours) {
 				case 0: break;
 				case 1: result += "1 hour"; break;
 				default: result += `${timeDiffHours} hours`; break;
 			}
 			if (timeDiffHours && timeDiffMinutesOfHour) result += " ";
 			switch (timeDiffMinutesOfHour) {
 				case 0: break;
 				case 1: result += "1 minute"; break;
 				default: result += `${timeDiffMinutesOfHour} minutes`; break;
 			}
 			return result;
 		}

		function isHot (actualTemp, feelsTemp, imperialUnits) {
			const hotTemp = imperialUnits ? 86 : 30; // 86F or 30C
			const temp = (feelsTemp !== null) ? feelsTemp : actualTemp;
			if (temp === null) return false;
			return (temp >= hotTemp);	
		}

		function isCold (actualTemp, feelsTemp, imperialUnits) {
			const coldTemp = imperialUnits ? 5 : -15; // 5F or -15C
			const temp = (feelsTemp !== null) ? feelsTemp : actualTemp;
			if (temp === null) return false;
			return (temp <= coldTemp);
		}

		function isWindy (windSpeed, imperialUnits) {
			if (windSpeed == null) return false;
			const windySpeedThreshold = imperialUnits ? 24.85 : 40; //40 km/h or 24.85 mph
			return (windSpeed >= windySpeedThreshold);
		}

		function currentWeatherToHTML(weather, imperialUnits, eol, tzOffsetMinutes) {
			var result = "";

			const tempUnit = imperialUnits ? "&deg;F" : "&degC";
			const pressureUnit = imperialUnits ? "&quot;Hg" : "hPa";
			const speedUnit = imperialUnits ? "mph" : "km/h";
			const visUnit = imperialUnits ? "miles" : "meters";
			const dirUnit = "&deg;";
			//Weather
			result += weatherToText(weather.weather, eol);
			//Additional weather data: windy, gusts, hot, cold
			if (isHot(weather.airTemperature, 
				weather.perceivedTemperature,
				imperialUnits))
			{
				result += "Hot"; result += eol;
			}
			if (isCold(weather.airTemperature, 
				weather.perceivedTemperature,
				imperialUnits))
			{
				result += "Cold"; result += eol;
			}
			if (isWindy(weather.windSpeed, imperialUnits)) {
				result += "Windy"; result += eol;
			} 
			if (isWindy(weather.gustSpeed, imperialUnits)) {
				result += "Gusty wind"; result += eol;
			}
			//Cloud data
			result += cloudToText(weather.cloud);
			if (weather.isStormClouds) result += " (storm clouds in the sky)";
			result += eol;
			//Temperature data
			result += `Temperature `;
			if (weather.airTemperature !== null) {
				result += `${weather.airTemperature}${tempUnit}`
			} else {
				result += `not specified`;
			}
			if (weather.airTemperatureHigh !== null) {
				result += `, high ${weather.airTemperatureHigh}${tempUnit}`
			}
			if (weather.airTemperatureLow !== null) {
				result += `, low ${weather.airTemperatureLow}${tempUnit}`
			}
			result += `${eol}`;
			if (weather.perceivedTemperature !== null) {
					result += `Feels like ${weather.perceivedTemperature}${tempUnit}${eol}`;
			}
			//Wind data
			if (weather.windDirection !== null || weather.windSpeed === null || weather.isWindVariable)
			{
				result += "Wind ";
				if (weather.windDirection !== null) { 
					const cardinal = directionToCardinalText(weather.windDirection);
					if (cardinal !== null) result += `is ${cardinal}ern, `;
					result += `${weather.windDirection}${dirUnit}`;
				} else {
					result += `is variable`;
				}
				if (weather.windSpeed !== null) {
					result += `, ${weather.windSpeed} ${speedUnit}`;
				}
				if (weather.gustSpeed !== null) {
					result += ` with gusts up to ${weather.gustSpeed} ${speedUnit}`;
				}
				result += eol;
			}
			//Relative humidity, visibility and atmospheric pressure
			if (weather.relativeHumidity !== null) {
				result += `RH ${weather.relativeHumidity}%${eol}`;
			}
			if (weather.visibility !== null) {
				result += `Visibility ${weather.visibility} ${visUnit}${eol}`;
			}
			if (weather.atmosphericPressure !== null) {
				var pressure = weather.atmosphericPressure;
				//in imperial units pressure is expressed in 1/100s of inch Hg
				if (imperialUnits) pressure /= 100.0; 
				result += `Atmospheric pressure ${pressure} ${pressureUnit}${eol}`;
			}
			//Update time
			if (weather.updateYear !== null && 
				weather.updateMonth !== null && 
				weather.updateDay !== null &&
				weather.updateHour !== null &&
				weather.updateMinute !== null) 
			{
				const updateTimeGMT = new Date(
					weather.updateYear,
					weather.updateMonth - 1,
					weather.updateDay,
					weather.updateHour,
					weather.updateMinute,
					0, //seconds
					0); //milliseconds
				const msPerMinute = 60000;
				const updateTimeLocal = 
					new Date(updateTimeGMT.getTime() + tzOffsetMinutes * msPerMinute);
				const updatedMinutesAgo = 
					Math.round((new Date().getTime() - updateTimeLocal.getTime()) / msPerMinute);
				const updatedAgo = timeDifferenceMinutesToString(updatedMinutesAgo); 
				const updateTimeStr = dateTimeToStr_HH_MM(updateTimeLocal);
				result += `Updated: ${updateTimeStr} (${updatedAgo} ago)${eol}`;
			}
			return(result);
		}

		function makeWeatherIcon(currentWeather, imperialUnits) {
			const isConsiderablyCloudy = (
				currentWeather.cloud === Module.Cloud.MOSTLY_CLOUDY.value || 
				currentWeather.cloud === Module.Cloud.OVERCAST.value);
			const isFog = (
				currentWeather.weather.includes(Module.Weather.FOG.value) ||
				currentWeather.weather.includes(Module.Weather.FOG_SHALLOW.value) ||
				currentWeather.weather.includes(Module.Weather.FOG_PARTIAL.value) ||
				currentWeather.weather.includes(Module.Weather.FOG_PATCHES.value) ||
				currentWeather.weather.includes(Module.Weather.FOG_FREEZING.value) ||
				currentWeather.weather.includes(Module.Weather.FOG_IN_VICINITY.value));
			const isSnow = (
				currentWeather.weather.includes(Module.Weather.SNOW_LIGHT.value) ||
				currentWeather.weather.includes(Module.Weather.SNOW_MODERATE.value) ||
				currentWeather.weather.includes(Module.Weather.SNOW_HEAVY.value) ||
				currentWeather.weather.includes(Module.Weather.SNOW_SHOWERS_LIGHT.value) ||
				currentWeather.weather.includes(Module.Weather.SNOW_SHOWERS_MODERATE.value) ||
				currentWeather.weather.includes(Module.Weather.SNOW_SHOWERS_HEAVY.value));
			const isRainLight = (
				currentWeather.weather.includes(Module.Weather.RAIN_LIGHT.value) ||
				currentWeather.weather.includes(Module.Weather.RAIN_SHOWERS_LIGHT.value));
			const isRainModerateToHeavy = (
				currentWeather.weather.includes(Module.Weather.RAIN_MODERATE.value) ||
				currentWeather.weather.includes(Module.Weather.RAIN_HEAVY.value) ||
				currentWeather.weather.includes(Module.Weather.RAIN_SHOWERS_MODERATE.value) ||
				currentWeather.weather.includes(Module.Weather.RAIN_SHOWERS_HEAVY.value));
			const isRain = isRainLight || isRainModerateToHeavy;
			const isWindyGustsSqualls = (
				isWindy(currentWeather.windSpeed, imperialUnits) || 
				isWindy(currentWeather.gustSpeed, imperialUnits) ||
				currentWeather.weather.includes(Module.Weather.SQUALLS.value));

			// Data not available
			var result = "&#xf07b;";
			// Clear or mostly clear
			if (currentWeather.cloud === Module.Cloud.CLEAR.value ||
				currentWeather.cloud === Module.Cloud.MOSTLY_CLEAR.value) 
			{
				result = "&#x0020;";
			}
			// Mostly cloudy or storm clouds
			if (currentWeather.cloud === Module.Cloud.MOSTLY_CLOUDY.value ||
				currentWeather.isStormClouds)
			{
				result = "&#xf041;";
			}
			// Overcast
			if (currentWeather.cloud === Module.Cloud.OVERCAST.value) result = "&#xf013;";
			// Hot / Cold
			if (isHot(currentWeather.airTemperature, currentWeather.perceivedTemperature, imperialUnits)) result = "&#xf072;";
			if (isCold(currentWeather.airTemperature, currentWeather.perceivedTemperature, imperialUnits)) result = "&#xf076;";
			// Windy / gusts / squalls (distinct icon when considerably cloudy)
			if (isWindyGustsSqualls)
			{
				result = isConsiderablyCloudy ? "&#xf011;" : "&#xf050;";
			}
			// Mist / haze (distinct icon when considerably cloudy)
			if (currentWeather.weather.includes(Module.Weather.MIST.value) ||
				currentWeather.weather.includes(Module.Weather.HAZE.value))
			{
				result = "&#xf021;";
			}
			// Fog
			if (isFog) result = "&#xf014;";
			// Smoke / smog
			if (currentWeather.weather.includes(Module.Weather.SMOKE.value)) {
				result = "&#xf062;";
				if (currentWeather.weather.includes(Module.Weather.MIST.value) || isFog) {
					result = "&#xf074;";
				}
			}
			// Sand / widespread dust / ice crystals
			if (currentWeather.weather.includes(Module.Weather.SAND.value) ||
				currentWeather.weather.includes(Module.Weather.WIDESPREAD_DUST.value) ||
				currentWeather.weather.includes(Module.Weather.ICE_CRYSTALS.value))
			{
				result = "&#xf063;";
			}
			// Precipitation in vicinity
			if (currentWeather.weather.includes(Module.Weather.PRECIPITATION_IN_VICINITY.value))
			{
				result = "&#xf084;";
			}
			//Drifting / blowing sand or dust, or blowing snow in vicinity
			if (currentWeather.weather.includes(Module.Weather.DRIFTING_DUST.value) ||
				currentWeather.weather.includes(Module.Weather.DRIFTING_SAND.value) ||
				currentWeather.weather.includes(Module.Weather.BLOWING_SAND.value) ||
				currentWeather.weather.includes(Module.Weather.BLOWING_DUST.value) ||
				currentWeather.weather.includes(Module.Weather.BLOWING_SPRAY.value) ||
				currentWeather.weather.includes(Module.Weather.BLOWING_DUST_IN_VICINITY.value) ||
				currentWeather.weather.includes(Module.Weather.BLOWING_SAND_IN_VICINITY.value) ||
				currentWeather.weather.includes(Module.Weather.BLOWING_SNOW_IN_VICINITY.value))
			{
				result = "&#xf082;";
			}
			// Dust or sand whirls
			if (currentWeather.weather.includes(Module.Weather.DUST_WHIRLS_IN_VICINITY.value) ||
				currentWeather.weather.includes(Module.Weather.DUST_WHIRLS.value))
			{
				result = "&#xf056;";
			}
			// Drizzle
			if (currentWeather.weather.includes(Module.Weather.DRIZZLE_LIGHT.value) ||
				currentWeather.weather.includes(Module.Weather.DRIZZLE_MODERATE.value) ||
				currentWeather.weather.includes(Module.Weather.DRIZZLE_HEAVY.value))
			{
				result = "&#xf01c;";
			}
			// Light rain or showers
			if (isRainLight) result = "&#xf01a;";	
			// Moderate to heavy rain or showers
			if (isRainModerateToHeavy) result = "&#xf019;";
			// Blowing snow
			if (currentWeather.weather.includes(Module.Weather.BLOWING_SNOW.value))
			{
				result = "&#xf082;";
			}
			// Snow or snow showers
			if (isSnow) result = "&#xf01b;";
			// Windy with rain
			if (isRain && isWindyGustsSqualls) result = "&#xf018;";
			// Light rain and snow mix
			if (isRainLight && isSnow) result = "&#xf017;";
			// Moderate to heavy rain and snow mix
			if (isRainModerateToHeavy && isSnow) result = "&#xf015;";
			// Windy with snow or blowing snow with falling snow
			if (isSnow && 
					(isWindyGustsSqualls || 
					currentWeather.weather.includes(Module.Weather.BLOWING_SNOW.value))
				)
			{
				result = "&#xf064;";
			}
			// Sandstorm or duststorm
			if (currentWeather.weather.includes(Module.Weather.SANDSTORM.value) ||
				currentWeather.weather.includes(Module.Weather.SANDSTORM_HEAVY.value) ||
				currentWeather.weather.includes(Module.Weather.SANDSTORM_IN_VICINITY.value) ||
				currentWeather.weather.includes(Module.Weather.DUSTSTORM.value) ||
				currentWeather.weather.includes(Module.Weather.DUSTSTORM_HEAVY.value) ||
				currentWeather.weather.includes(Module.Weather.DUSTSTORM_IN_VICINITY.value))
			{
				result = "&#xf082;";
			}
			// Hail or graupel
			if (currentWeather.weather.includes(Module.Weather.HAIL.value) ||
				currentWeather.weather.includes(Module.Weather.GRAUPEL.value))
			{
				result = "&#xf0b5;";
			}
			// Thunderstorm in vicinity
			if (currentWeather.weather.includes(Module.Weather.THUNDERSTORM_IN_VICINITY.value)) 
			{
				result = "&#xf016;";
			}
			// Thunderstorm
			if (currentWeather.weather.includes(Module.Weather.THUNDERSTORM.value)) 
			{
				result = "&#xf016;";
				if (isRainLight) result = "&#xf01d;";
				if (isRainModerateToHeavy) result = "&#xf01e;";
			}
			// Freezing precipitation
			if (currentWeather.weather.includes(Module.Weather.DRIZZLE_FREEZING_LIGHT.value) ||
				currentWeather.weather.includes(Module.Weather.DRIZZLE_FREEZING_MODERATE.value) ||
				currentWeather.weather.includes(Module.Weather.DRIZZLE_FREEZING_HEAVY.value) ||
				currentWeather.weather.includes(Module.Weather.RAIN_FREEZING_LIGHT.value) ||
				currentWeather.weather.includes(Module.Weather.RAIN_FREEZING_MODERATE.value) ||
				currentWeather.weather.includes(Module.Weather.RAIN_FREEZING_HEAVY.value))
			{
				result = '<img class="ww_freezing_precip" src="weather_widget/icicles-solid-wh.svg">';
			}
			// Volcanic ash (or in vicnity)
			if (currentWeather.weather.includes(Module.Weather.VOLCANIC_ASH.value) ||
				currentWeather.weather.includes(Module.Weather.VOLCANIC_ASH_IN_VICINITY.value))
			{
				result = "&#xf0c8;";
			}
			// Funnel cloud, tornado or waterspout
			if (currentWeather.weather.includes(Module.Weather.FUNNEL_CLOUD.value) ||
				currentWeather.weather.includes(Module.Weather.TORNADO.value))
			{
				result = "&#xf056;";
			}
			// Finally
			return result;
		}

		function makeWeatherWidget(currentWeather, imperialUnits) {
			const tempStyle = imperialUnits ? "ww_temp_f" : "ww_temp_c";
			const tempFeelsStyle = imperialUnits ? "ww_temp_feels_f" : "ww_temp_feels_c";
			const tempHighStyle = imperialUnits ? "ww_temp_high_f" : "ww_temp_high_c";
			const tempLowStyle = imperialUnits ? "ww_temp_low_f" : "ww_temp_low_c";
			const pressureStyle = imperialUnits ? "ww_pres_inhg" : "ww_pres_hpa";
			const rhStyle = "ww_rh";
			const windStyle = imperialUnits ? "ww_wind_mph" : "ww_wind_kmh";
			const visStyle = imperialUnits ? "ww_vis_mile" : "ww_vis_km";
			const windIconStyle = currentWeather.isWindVariable ? 
				`` : ` style="transform: rotate(${currentWeather.windDirection}deg) scaleY(-1);"`;
			const windIconClass = 
				currentWeather.isWindVariable ? "ww_wind_vrb_icon" : "ww_wind_dir_icon";
			const decimalRadix = 10;

			var gustStyle = imperialUnits ? "ww_gust_mph" : "ww_gust_kmh";
			if (currentWeather.gustSpeed === null) gustStyle = "ww_no_gust";
			const gustStr = 
				valueOrNullToString(currentWeather.gustSpeed, "");

			const tempStr = 
				valueOrNullToString(currentWeather.airTemperature, "==");
			const tempFeelsStr = 
				valueOrNullToString(currentWeather.perceivedTemperature, "==");
			const tempHighStr = 
				valueOrNullToString(currentWeather.airTemperatureHigh, "==");
			const tempLowStr = 
				valueOrNullToString(currentWeather.airTemperatureLow, "==");
	
			const rhStr = 
				valueOrNullToString(currentWeather.relativeHumidity, "==");

			const pressureVal = 
				imperialUnits ? 
				currentWeather.atmosphericPressure / 100.0 : 
				currentWeather.atmosphericPressure;
			const pressureStr = 
				valueOrNullToString(pressureVal, "==");

			const windStr = 
				valueOrNullToString(currentWeather.windSpeed, "==");

			const metersPerKm = 1000;
			const vis = imperialUnits ? 
				currentWeather.visibility : 
				currentWeather.visibility / metersPerKm; 
			const visStr = 
				valueOrNullToString(vis, "==");

			const weatherIconStr = makeWeatherIcon(currentWeather, imperialUnits);

			return (`
				<div class="weather_widget">
					<div class="ww_weather">${weatherIconStr}</div>
					<div class="ww_temp_icon">&#xf055;</div>
					<div class="${tempStyle}">${tempStr}</div>
					<div class="${tempFeelsStyle}">${tempFeelsStr}</div>
					<div class="${windIconClass}"${windIconStyle}>&#xf0b1;</div>
					<div class="${windStyle}">${windStr}</div>
					<div class="${gustStyle}">${gustStr}</div>
					<div class="ww_other">
						<span class="${tempLowStyle}">${tempLowStr}</span>
						<span class="${tempHighStyle}">${tempHighStr}</span>
						<span class="${rhStyle}">${rhStr}</span>
						<br>
						<span class="${pressureStyle}">${pressureStr}</span>
						<span class="${visStyle}">${visStr}</span>
					</div>
				</div>`
			);
		}

		function displayAerodromeCount(count) {
			const aerodromes = (count == 1) ? "aerodrome" : "aerodromes";
			const decimalRadix = 10;
			const c = (count > 0) ? count.toString(decimalRadix) : "No";
			document.getElementById('weatherdataid').innerHTML += `<div class="weatherdataitem">${c} ${aerodromes} within selected range</div>`;
		}

		function displayWeatherData(name, distKm, currWeather, imperialUnits, tzOffsetMinutes) {
			const eol = "<br>";
			var result = "<div class=\"weatherdataitem\">";
			result += "<div class=\"weatherstation\">";
			if (name !== null && name != "") {
				result += name;
			} else {
				result += "NAME UNKNOWN";
			}
			if (distKm !== null) {
				const milesPerKm = 1.609344;
				const distStr = imperialUnits ? 
					`${Math.round(distKm/milesPerKm)} miles` : 
					`${Math.round(distKm)} km`;
				result = result + " (" + distStr + " away)";
			}
			result += "</div>";//div class=weatherstation
	
			result += '<div class="widget">'
			result += makeWeatherWidget(currWeather, imperialUnits);
			result += "</div>";//div class=widget

			result += '<div class="weathertext">';
			result += currentWeatherToHTML(currWeather, imperialUnits, eol, tzOffsetMinutes);
			result += "</div>";//div class=weathertext
			result += "</div>";//div class=weatherdataitem
	
			document.getElementById('weatherdataid').innerHTML += result;
		}

		function clearDisplayedWeatherData() {
			document.getElementById('weatherdataid').innerHTML = "";	
		}

		function displayWeatherDataMessage(message) {
			document.getElementById('weatherdataid').innerHTML = message;	
		}

		function valueOrNullToString (value, nullValue) {
			const decimalRadix = 10;
			if (value === null) return nullValue;
			return value.toString(decimalRadix);
		}

		function findGetParameter(parameterName) {
			//from https://stackoverflow.com/questions/5448545/how-to-retrieve-get-parameters-from-javascript
			var result = null,
				tmp = [];
			var items = location.search.substr(1).split("&");
			for (var index = 0; index < items.length; index++) {
				tmp = items[index].split("=");
				if (tmp[0] === parameterName) result = decodeURIComponent(tmp[1]);
			}
			return result;
		}

		function displayUnitOptions(imperialUnits, distance) {
			const metricUnitOn = imperialUnits ? "" : " option_on";
			const imperialUnitOn = imperialUnits ? " option_on" : "";
			var options = `
				<ul class="options">
				<div class="options_caption">Display units</div>
				<li class="option${metricUnitOn}"><a href="?distance=${distance}">Metric<br>(&deg;C, km, km/h, hPa)</a></li>
				<li class="option${imperialUnitOn}"><a href="?distance=${distance}&unit=imperial">Imperial<br>(&deg;F, miles, mph, &quot;Hg)</a>
				</ul>`;
			document.getElementById('options_units').innerHTML = options;	
		}

		function displayDistanceOptions(imperialUnits, distance) {
			const dist3smOn = (distance == 3) ? " option_on" : "";
			const dist10smOn = (distance == 10) ? " option_on" : "";
			const dist30smOn = (distance == 30) ? " option_on" : "";
			const dist75smOn = (distance == 75) ? " option_on" : "";
			const dist140smOn = (distance == 140) ? " option_on" : "";
			const dist320smOn = (distance == 320) ? " option_on" : "";
			const dist500smOn = (distance == 500) ? " option_on" : "";
			const unitParam = imperialUnits ? "&unit=imperial" : "";
			var options = `
				<ul class="options">
				<div class="options_caption">Display aerodromes within</div>
				<li class="option${dist3smOn}"><a href="?distance=3${unitParam}">3 miles / 5 km</a></li>
				<li class="option${dist10smOn}"><a href="?distance=10${unitParam}">10 miles / 16 km</a></li>
				<li class="option${dist30smOn}"><a href="?distance=30${unitParam}">30 miles / 48 km</a></li>
				<li class="option${dist75smOn}"><a href="?distance=75${unitParam}">75 miles / 120 km</a></li>
				<li class="option${dist140smOn}"><a href="?distance=140${unitParam}">140 miles / 225 km</a></li>
				<li class="option${dist320smOn}"><a href="?distance=320${unitParam}">320 miles / 515 km</a></li>
				<li class="option${dist500smOn}"><a href="?distance=500${unitParam}">500 miles / 804 km</a></li>
				</ul>`;
			document.getElementById('options_distance').innerHTML = options;
		}

		function displayErrors(caption, errors) {
			const eol = "<br>";
			var result = "";
			var displayResult = false;
			for (i = 0; i<errors.length; i++) {
				errors[i].childNodes.forEach(value => {
					const errorMessage = value.innerHTML;
					if (errorMessage !== null && typeof errorMessage !== 'undefined') {
						result += errorMessage;
						result += eol;
						displayResult = true;
					}
				});
			}
			if (displayResult) {
			document.getElementById('weatherdataid').innerHTML += 
				`<div class=\"weatherdataitem\">
					<div class=\"weatherstation\">${caption}</div>
					${result}
				</div>`;
			}
		}

		function AWCdataToMap(metarData, tafData, latitude, longitude) {
			var weatherData = new Map();
			//Add METARs to weather data
			for (i = 0; i<metarData.length; i++) {
				const metar = getReportFromNodeList(metarData[i].childNodes);
				const dist = distanceKm(metar.lat, metar.lon, latitude, longitude);
				weatherData.set(metar.id, 
					{	name:"", 
						lat:metar.lat,
						lon:metar.lon, 
						distKm:dist, 
						metar:metar.report, 
						taf:""
					});
			}
			//Add TAFs to weather data
			for (i = 0; i<tafData.length; i++) {
				const taf = getReportFromNodeList(tafData[i].childNodes);
				if (weatherData.has(taf.id)) {
					var weatherDataElement = weatherData.get(taf.id);
					weatherDataElement.taf = taf.report;
					weatherData.set(taf.id, weatherDataElement);
				} else {
					const dist = distanceKm(taf.lat, taf.lon, latitude, longitude);
					weatherData.set(taf.id,
						{	name:"",
							lat:taf.lat,
							lon:taf.lon, 
							distKm:dist, 
							metar:"", 
							taf:taf.report
						});
				}
			}
			return(weatherData);
		}

		function addStationNames(weatherData, stationData) {
			for (i = 0; i<stationData.length; i++) {
				const station = getStationFromNodeList(stationData[i].childNodes);
				if (weatherData.has(station.id)) {
					var weatherDataElement = weatherData.get(station.id);
					weatherDataElement.name = station.name;
					weatherData.set(station.id, weatherDataElement);
				}
			}
			return(weatherData);
		}

		function getAWCweather(latitude, longitude, distance) {
			const metarUrl = `https://cors-anywhere.herokuapp.com/https://www.aviationweather.gov/adds/dataserver_current/httpparam?dataSource=metars&requestType=retrieve&format=xml&radialDistance=${distance};${longitude},${latitude}&hoursBeforeNow=3&mostRecentForEachStation=true&fields=raw_text,station_id,latitude,longitude`;			
			const tafUrl = `https://cors-anywhere.herokuapp.com/https://www.aviationweather.gov/adds/dataserver_current/httpparam?dataSource=tafs&requestType=retrieve&format=xml&radialDistance=${distance};${longitude},${latitude}&hoursBeforeNow=24&mostRecentForEachStation=true`;
			const stationUrl = `https://cors-anywhere.herokuapp.com/https://www.aviationweather.gov/adds/dataserver_current/httpparam?dataSource=stations&requestType=retrieve&format=xml&radialDistance=${distance};${longitude},${latitude}&fields=station_id,site`;
			console.log("Fetching METAR & TAF data from AWC");
			displayWeatherDataMessage("Retreiving weather data...");
			return Promise.all([fetchAndParseXML(metarUrl), 
				fetchAndParseXML(tafUrl),
				fetchAndParseXML(stationUrl)])
				.catch(err => { 
					console.log("Fetching data from AWC failes: ", err);
					displayWeatherDataMessage("Unable to retreive weather data");
				})
				.then(metarTafData => {
					const timeOffset = metarTafData[0][1];
					const metarData = metarTafData[0][0].getElementsByTagName("METAR");
					const tafData = metarTafData[1][0].getElementsByTagName("TAF");
					const stationData = metarTafData[2][0].getElementsByTagName("Station");
					const metarErrors = metarTafData[0][0].getElementsByTagName("errors");
					const tafErrors = metarTafData[1][0].getElementsByTagName("errors");
					const stationErrors = metarTafData[2][0].getElementsByTagName("errors");
					displayWeatherDataMessage("Processing weather data...");
					console.log("Processing received AWC data");
					var weatherData = AWCdataToMap(metarData, tafData, latitude, longitude);
					weatherData = addStationNames(weatherData, stationData);
					console.log("Actual time zone offset: ", timeOffset);
					console.log("Weather data: ", weatherData);
					console.log("Displaying weather data");
					const imperialUnits = (findGetParameter("unit") == "imperial"); 
					clearDisplayedWeatherData();
					displayErrors("METAR errors", metarErrors);
					displayErrors("TAF errors", tafErrors);
					displayErrors("Station data errors", stationErrors);
					displayAerodromeCount(weatherData.size);
					const currDate = new Date();
					weatherData.forEach( (value, key, map) => {
						var currWeather = Module.getCurrentWeather(value.metar, value.taf, currDate.getFullYear(), currDate.getMonth() + 1, currDate.getDate(), imperialUnits);
						currWeather = adaptCurrentWeather(currWeather, Module.valueNotSpecified);
						displayWeatherData(value.name, value.distKm, currWeather, imperialUnits, timeOffset);
					});
					console.log("Finished");
				})
				.catch(err => {
					console.log("Processing weather data failed: ", err);
				})
		}

		function getPositionSuccess(pos) {
			const latitude = Math.round(pos.coords.latitude * 100) / 100;
			const longitude = Math.round(pos.coords.longitude * 100) / 100;
			console.log("Geolocation latitude: ", latitude);
			console.log("Geolocation longitude: ", longitude);
			var distance = Number(findGetParameter("distance"));
			if (isNaN(distance) || !distance) distance = 30;
			console.log("Distance radius: ", distance);
			getAWCweather(latitude, longitude, distance);
		}

		function getPositionFailure(err) {
			console.log("Geolocation failed: ", err);
			displayWeatherDataMessage("Unable to acquire position");
		}

		function getWeatherSummaryForPosition() {
			const options = {
			  enableHighAccuracy: true,
			  timeout: 10000,
			  maximumAge: 60000
			};
			displayWeatherDataMessage("Geolocating...");
			navigator.geolocation.getCurrentPosition(
				getPositionSuccess, 
				getPositionFailure,
				options);
		}

		function updateOptions(){
			const paramUnit = (findGetParameter("unit") == "imperial");
			var paramDistance = Number(findGetParameter("distance"));
			if (!paramDistance || isNaN(paramDistance)) paramDistance = 30;
			displayUnitOptions(paramUnit, paramDistance);
			displayDistanceOptions(paramUnit, paramDistance);
		}

	var Module = {
		onRuntimeInitialized: function() {
			updateOptions();
			getWeatherSummaryForPosition();
	  }
	};


	</script>

	{{{ SCRIPT }}}

</head>
<body>
 
	<ul class="navbar">
		<li class="navitem"><a href="../index.html">About</a></li>
		<li class="navitem"><a href="https://gitlab.com/nnaumenko/metaf/" target="_blank">Repository</a></li>
		<li class="navitem navactive"><a href="../examples.html">Examples</a></li>
		<li class="navitem"><a href="../docs/index.html" target="_blank">Documentation</a></li>
	</ul>

	<h1>Short weather summary for aerodromes near your location based on METAR/TAF weather data</h1>

	<div id="options_units"></div>
	<div id="options_distance"></div>

	<div class="weatherdata" id="weatherdataid">Preparing...</div>

	<br>
	<div style="font-size: smaller">
	The following external content was used in this page:&nbsp;<a href="http://weathericons.io">Weather Icons by Erik Flowers</a>&nbsp;distributed under&nbsp;<a href="http://scripts.sil.org/OFL">SIL OFL 1.1 license</a>,&nbsp;<a href="https://fonts.google.com/specimen/Source+Sans+Pro">Source Sans Pro Font</a>&nbsp;by Paul D. Hunt distributed under&nbsp;<a href="http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=OFL_web">Open Font License</a>,&nbsp;<a href="https://fontawesome.com/icons/eye?style=regular">'eye-regular'</a>&nbsp;and&nbsp;<a href="https://fontawesome.com/icons/icicles?style=solid">'icicles-solid'</a>&nbsp;icons&nbsp;by Font Awesome distributed under&nbsp;<a href="https://fontawesome.com/license">Creative Commons Attribution 4.0 International license</a>. METAR, TAF, and weather station data are acquired from&nbsp;<a href="https://www.aviationweather.gov/dataserver">Aviation Weather Center Text Data Server</a>&nbsp;using&nbsp;<a href="https://cors-anywhere.herokuapp.com/">CORS-anywhere</a>.</div>
</body>
</html>

